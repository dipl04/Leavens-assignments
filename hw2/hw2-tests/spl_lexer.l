/* $Id: spl_lexer_definitions_top.l,v 1.4 2024/10/06 19:16:25 leavens Exp leavens $ */
/* Lexical Analyzer for SPL */

%option header-file = "spl_lexer.h"
%option outfile = "spl_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "spl.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
static char *input_filename;

/* Have any errors been noted? */
static bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

// We are not using yyunput or input
#define YY_NO_UNPUT
#define YY_NO_INPUT

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(input_filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    assert(input_filename != NULL);
    t.ident.file_loc = file_location_make(input_filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(input_filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

 /* you can add actual definitions below, before the %% */


 /* our rules are below JL */
// reserved words rules below JM

%%

["const"|"var"|"proc"|"call"|"begin"|"end"|"if"|"then"|"else"|"while"|"do"|"read"|"print"|"divisible"|"by"] {
	if (strcmp(yytext, "const") == 0) {
      tok2ast(constsym);
      return constsym;
  }

  if (strcmp(yytext, "var") == 0) {
      tok2ast(varsym);
      return varsym;
  }

  if (strcmp(yytext, "proc") == 0) {
      tok2ast(procsym);
      return procsym;
  }

  if (strcmp(yytext, "call") == 0) {
      tok2ast(callsym);
      return callsym;
  }

  if (strcmp(yytext, "begin") == 0) {
      tok2ast(beginsym);
      return beginsym;
  }

  if (strcmp(yytext, "end") == 0) {
      tok2ast(endsym);
      return endsym;
  }

  if (strcmp(yytext, "if") == 0) {
      tok2ast(ifsym);
      return ifsym;
  }

  if (strcmp(yytext, "then") == 0) {
      tok2ast(thensym);
      return thensym;
  }

  if (strcmp(yytext, "else") == 0) {
      tok2ast(elsesym);
      return elsesym;
  }

  if (strcmp(yytext, "while") == 0) {
			tok2ast(whilesym);
      return whilesym;
  }

  if (strcmp(yytext, "do") == 0) {
      tok2ast(dosym);
      return dosym;
  }

  if (strcmp(yytext, "read") == 0) {
      tok2ast(readsym);
    	return readsym;
	}

  if (strcmp(yytext, "print") == 0) {
      tok2ast(printsym);
      return printsym;
  }

  if (strcmp(yytext, "divisible") == 0) {
      tok2ast(divisiblesym);
      return divisiblesym;
  }

  if (strcmp(yytext, "by") == 0) {
      tok2ast(bysym);
      return bysym;
  }

  ident2ast(yytext); 
  return identsym; 
}

[a-z]+ {
	ident2ast(yytext);
	return identsym;
}

[0-9]+ { 
  number2ast(atoi(yytext)); 
  return numbersym; 
}

["+"|"-"|"*"|"/"|"."|";"|"="|","|":="|"("|")"|"=="|"!="|"<"|">"|"<="|">="] {

	if (strcmp(yytext, "+") == 0) {
		tok2ast(plussym);
		return plussym;
	}

	if (strcmp(yytext, "-") == 0) {
		tok2ast(minussym);
		return minussym;
	}

	if (strcmp(yytext, "*") == 0) {
		tok2ast(multsym);
		return multsym;
	}

	if (strcmp(yytext, "/") == 0) {
		tok2ast(divsym);
		return divsym;
	}

	if (strcmp(yytext, "+") == 0) {
		tok2ast(plussym);
		return plussym;
	}

	if (strcmp(yytext, ".") == 0) {
		tok2ast(periodsym);
		return periodsym;
	}

	if (strcmp(yytext, ";") == 0) {
		tok2ast(semisym);
		return semisym;
	}

	if (strcmp(yytext, "=") == 0) {
		tok2ast(eqsym);
		return eqsym;
	}

	if (strcmp(yytext, ",") == 0) {
		tok2ast(commasym);
		return commasym;
	}

	if (strcmp(yytext, ":=") == 0) {
		tok2ast(becomessym);
		return becomessym;
	}

	if (strcmp(yytext, "(") == 0) {
		tok2ast(lparensym);
		return lparensym;
	}

	if (strcmp(yytext, ")") == 0) {
		tok2ast(rparensym);
		return rparensym;
	}

	if (strcmp(yytext, "==") == 0) {
		tok2ast(eqeqsym);
		return eqeqsym;
	}

	if (strcmp(yytext, "!=") == 0) {
		tok2ast(neqsym);
		return neqsym;
	}

	if (strcmp(yytext, "<") == 0) {
		tok2ast(ltsym);
		return ltsym;
	}

	if (strcmp(yytext, ">") == 0) {
		tok2ast(gtsym);
		return gtsym;
	}

	if (strcmp(yytext, "<=") == 0) {
		tok2ast(leqsym);
		return leqsym;
	}

	if (strcmp(yytext, ">=") == 0) {
		tok2ast(geqsym);
		return geqsym;
	}
}

[ \t\n]+ {

}

. {
	char myString[100];
	sprintf(myString, "invalid character: '%c' ('\\0%o')", yytext, yytext);
  yyerror(input_filename, myString); 
}

%%

 /* This code goes in the user code section of the spl_lexer.l file,
   following the last %% above. */

// Requires: fname != NULL
// Requires: fname is the name of a readable file
// Initialize the lexer and start it reading
// from the given file name
void lexer_init(char *fname) {
  errors_noted = false;
  yyin = fopen(fname, "r");
  if (yyin == NULL) {
		bail_with_error("Cannot open %s", fname);
  }
  input_filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
  if (yyin != NULL) {
		int rc = fclose(yyin);
		if (rc == EOF) {
	    bail_with_error("Cannot close %s!", input_filename);
		}
  }
  input_filename = NULL;
  return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
  return input_filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
  return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg) {
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", input_filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Have any errors been noted by the lexer?
bool lexer_has_errors()
{
    return errors_noted;
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
        }
        lexer_print_token(t, yylineno, yytext);
    } while (t != YYEOF);
}
